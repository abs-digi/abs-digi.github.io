---
import BaseLayout from '../layouts/BaseLayout.astro';
// IMPORTANT: Ensure your file is at src/data/bookmarks.json
import bookmarksData from '../data/bookmarks.json';

const title = 'All Bookmarks';
const description = 'My complete collection of digital resources.';

// --- Data Processing Script ---

// Type definition for the bookmark nodes
interface BookmarkNode {
    title: string;
    typeCode: number; // 1 = Bookmark, 2 = Folder
    uri?: string;
    children?: BookmarkNode[];
}

interface LinkGroup {
    category: string;
    links: { title: string; url: string }[];
}

// Recursive function to extract all links while preserving folder structure
function flattenBookmarks(node: BookmarkNode, path: string[] = []): LinkGroup[] {
    let groups: LinkGroup[] = [];
    
    // Define current path name (ignore root/menu generic names if preferred, or keep them)
    // We skip adding the folder name if it's empty
    const currentPath = node.title ? [...path, node.title] : path;

    // 1. If this node has children, process them
    if (node.children && node.children.length > 0) {
        
        // Separate direct bookmarks from sub-folders
        const directLinks = node.children
            .filter(c => c.typeCode === 1 && c.uri) // typeCode 1 is a link
            .map(c => ({ 
                title: c.title || 'Untitled', 
                url: c.uri || '#' 
            }));

        // If we found links in this folder, add them as a group
        if (directLinks.length > 0) {
            // Create a breadcrumb string like "Menu > Linux > Servers"
            // If path is empty, call it "Uncategorized"
            const categoryName = currentPath.length > 0 ? currentPath.join(' / ') : 'Root';
            
            groups.push({
                category: categoryName,
                links: directLinks
            });
        }

        // 2. Recursively process sub-folders
        const subFolders = node.children.filter(c => c.typeCode === 2); // typeCode 2 is a container
        for (const folder of subFolders) {
            groups = groups.concat(flattenBookmarks(folder, currentPath));
        }
    }

    return groups;
}

// Execute the flattening
// We cast bookmarksData because JSON imports can be loosely typed
const allGroups = flattenBookmarks(bookmarksData as BookmarkNode);

---

<BaseLayout title={title} description={description} showHeader={true}>
    <section class="mx-auto mb-16 max-w-4xl px-4 sm:mb-24">
        <header class="mb-12 text-center">
            <h1 class="mb-6 font-serif text-3xl italic sm:text-5xl">{title}</h1>
            <p class="text-lg opacity-80">{description}</p>
        </header>

        {/* Search Bar */}
        <div class="sticky top-4 z-10 mb-12">
            <input 
                type="text" 
                id="link-search" 
                placeholder="Search links..." 
                class="w-full rounded-full border border-main bg-[var(--bg-main)] px-6 py-3 font-serif text-lg shadow-lg focus:outline-none focus:ring-2 focus:ring-purple-500 transition-all"
            />
        </div>
        
        <div id="links-container" class="space-y-16">
            {allGroups.map((group) => (
                <div class="link-group reveal">
                    <h2 class="mb-6 border-b border-dashed border-main pb-2 font-serif text-xl font-medium text-purple-700 dark:text-purple-300 sm:text-2xl">
                        {group.category}
                    </h2>
                    <div class="grid gap-4 sm:grid-cols-2 md:grid-cols-3">
                        {group.links.map((link) => (
                            <a 
                                href={link.url} 
                                target="_blank"
                                rel="noopener noreferrer"
                                class="link-card group flex flex-col justify-between rounded-lg border border-main p-4 transition-all hover:-translate-y-1 hover:shadow-hard hover:bg-[var(--bg-muted)]"
                                data-search={link.title.toLowerCase()}
                            >
                                <span class="font-medium break-words line-clamp-2" title={link.title}>{link.title}</span>
                                <div class="mt-3 flex items-center justify-end opacity-0 transition-opacity group-hover:opacity-100">
                                    <svg xmlns="http://www.w3.org/2000/svg" class="h-4 w-4" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14" />
                                    </svg>
                                </div>
                            </a>
                        ))}
                    </div>
                </div>
            ))}
        </div>
    </section>
</BaseLayout>

<script>
    // Simple Client-Side Search
    const searchInput = document.getElementById('link-search');
    const container = document.getElementById('links-container');

    if (searchInput && container) {
        searchInput.addEventListener('input', (e) => {
            const term = (e.target as HTMLInputElement).value.toLowerCase();
            const groups = container.querySelectorAll('.link-group');

            groups.forEach((group) => {
                const links = group.querySelectorAll('.link-card');
                let hasVisibleLinks = false;

                links.forEach((link) => {
                    const text = link.getAttribute('data-search') || '';
                    if (text.includes(term)) {
                        (link as HTMLElement).style.display = 'flex';
                        hasVisibleLinks = true;
                    } else {
                        (link as HTMLElement).style.display = 'none';
                    }
                });

                // Hide the entire category header if no links match
                (group as HTMLElement).style.display = hasVisibleLinks ? 'block' : 'none';
            });
        });
    }
</script>

<style>
    .link-card {
        text-decoration: none;
        min-height: 100px; /* Uniform height for cards */
    }
    
    /* Scroll Reveal (ensure this matches your global.css) */
    .reveal {
        animation: fadeIn 0.5s ease-out forwards;
    }
    
    @keyframes fadeIn {
        from { opacity: 0; transform: translateY(10px); }
        to { opacity: 1; transform: translateY(0); }
    }
</style>